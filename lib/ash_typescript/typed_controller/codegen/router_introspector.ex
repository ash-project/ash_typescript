# SPDX-FileCopyrightText: 2025 ash_typescript contributors <https://github.com/ash-project/ash_typescript/graphs/contributors>
#
# SPDX-License-Identifier: MIT

defmodule AshTypescript.TypedController.Codegen.RouterIntrospector do
  @moduledoc """
  Introspects a Phoenix Router to match routes to generated controllers.

  Uses `Router.__routes__/0` to discover the actual URL paths for
  controller actions generated by the TypedController extension.

  When a controller is mounted at multiple scopes, each mount produces
  a separate path helper function. The scopes must use `as:` options
  to provide unique Phoenix helper names for disambiguation.
  """

  @doc """
  Gets route information by matching router entries to DSL-configured routes.

  Returns a list of matched route info maps. When a controller action is
  mounted at multiple paths, returns one entry per mount with a `scope_prefix`
  derived from the Phoenix helper name.

  ```
  %{
    source_module: source_module,
    controller: controller_module,
    route: %Route{},
    path: "/admin/pages/:id",
    method: :get,
    path_params: [:id],
    scope_prefix: "admin"  # nil when single mount
  }
  ```

  Raises if a controller action is mounted at multiple paths but the scopes
  don't have unique `as:` options (making disambiguation impossible).
  """
  def introspect(router_module, routes_config) do
    router_routes = router_module.__routes__()

    Enum.flat_map(routes_config, fn {source_module, controller_module, routes} ->
      Enum.flat_map(routes, fn route ->
        matches =
          Enum.filter(router_routes, fn router_route ->
            router_route.plug == controller_module and
              router_route.plug_opts == route.name
          end)

        case matches do
          [] ->
            [
              %{
                source_module: source_module,
                controller: controller_module,
                route: route,
                path: nil,
                method: route.method,
                path_params: [],
                scope_prefix: nil
              }
            ]

          [single] ->
            [build_route_info(source_module, controller_module, route, single, nil)]

          multiple ->
            build_multi_mount_route_infos(source_module, controller_module, route, multiple)
        end
      end)
    end)
  end

  defp build_route_info(source_module, controller_module, route, router_route, scope_prefix) do
    path_params = extract_path_params(router_route.path)

    %{
      source_module: source_module,
      controller: controller_module,
      route: route,
      path: router_route.path,
      method: resolve_method(router_route.verb),
      path_params: path_params,
      scope_prefix: scope_prefix
    }
  end

  defp build_multi_mount_route_infos(source_module, controller_module, route, matches) do
    helpers = Enum.map(matches, & &1.helper)
    unique_helpers = Enum.uniq(helpers)

    if length(unique_helpers) < length(matches) do
      raise_ambiguous_mount_error(controller_module, route, matches)
    end

    base_suffix = longest_common_suffix(unique_helpers)

    Enum.map(matches, fn match ->
      prefix = extract_scope_prefix(match.helper, base_suffix)
      build_route_info(source_module, controller_module, route, match, prefix)
    end)
  end

  defp raise_ambiguous_mount_error(controller_module, route, matches) do
    controller_name = controller_module |> to_string() |> String.trim("Elixir.")

    path_list =
      Enum.map_join(matches, "\n", fn match ->
        verb = match.verb |> to_string() |> String.upcase()
        "    - #{verb} #{match.path}"
      end)

    raise """
    Controller #{controller_name} action :#{route.name} is mounted at multiple paths \
    in the router, but the scopes don't have unique `as:` options:

    #{path_list}

    Add `as:` options to the router scopes to disambiguate. For example:

        scope "/first-scope", as: :first_scope do
          get "/...", #{controller_name}, :#{route.name}
        end

        scope "/second-scope", as: :second_scope do
          get "/...", #{controller_name}, :#{route.name}
        end
    """
  end

  defp extract_scope_prefix(helper, base_suffix) do
    helper
    |> String.trim_trailing(base_suffix)
    |> String.trim_trailing("_")
  end

  defp longest_common_suffix(strings) do
    strings
    |> Enum.map(&String.reverse/1)
    |> longest_common_prefix()
    |> String.reverse()
  end

  defp longest_common_prefix([]), do: ""
  defp longest_common_prefix([single]), do: single

  defp longest_common_prefix([first | rest]) do
    Enum.reduce(rest, first, fn string, acc ->
      acc
      |> String.graphemes()
      |> Enum.zip(String.graphemes(string))
      |> Enum.take_while(fn {a, b} -> a == b end)
      |> Enum.map_join(fn {a, _} -> a end)
    end)
  end

  defp extract_path_params(path) do
    Regex.scan(~r/:(\w+)/, path)
    |> Enum.map(fn [_, param] -> String.to_atom(param) end)
  end

  defp resolve_method(verb) when is_atom(verb), do: verb

  defp resolve_method(verb) when is_binary(verb) do
    verb |> String.downcase() |> String.to_atom()
  end
end
